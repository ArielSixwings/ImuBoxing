#include "Knn.h"

#include <algorithm>
#include <iostream>
#include <iterator>
#include <ranges>

namespace classifier::strategy
{
    LabeledDistance Knn::Data::EuclideanDistance(const Data &other)
    {
        if (Features.size() != other.Features.size())
        {
            throw std::invalid_argument("Data Features must be of the same size.");
        }

        double sumSquaredDiff = 0.0;

        std::ranges::for_each(Features, other.Features, [&](double feature, double otherFeature)
                              { sumSquaredDiff += std::pow(feature - otherFeature, 2); });

        return LabeledDistance(std::sqrt(sumSquaredDiff), other.Label);
    }

    LabeledDistance Knn::AddData(const std::vector<Data> &data)
    {
        m_data.insert(m_data.end(), data.begin(), data.end());
    }

    Data Knn::Classify(Data &data)
    {

        std::ranges::transform(m_data,
                               std::back_inserter(m_neighbors),
                               [&data](const auto &dataPoint)
                               { return data.EuclideanDistance(dataPoint); });

        std::ranges::sort(m_neighbors);

        std::vector<LabeledDistance> candidates;

        candidates.insert(candidates.begin(),
                          m_neighbors.begin(), std::next(m_neighbors.begin(), std::min(m_neighbors.size(), m_k)));

        std::vector<unit8_t> labels(m_k);

        std::ranges::for_each(candidates, [&labels](const auto candidate)
                              { ++labels[candidate.Label]; });

        data.Label = std::ranges::max(labels);

        return data;
    }
}